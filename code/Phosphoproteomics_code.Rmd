---
title: "Phosphoproteomics"
output: html_notebook

---
***
#### Download raw data from Uppmax

```{bash}
rsync -r noahe@rackham.uppmax.uu.se:/proj/g2020004/private/student_projects/phosphoproteomics /home/noah/phosphoproteomics_project/
```

#### Setting working directory and libraries

```{r}
setwd("~/phosphoproteomics_project")
RequiredPackages <- c("BiocManager", "dplyr", "igraph", "tidyr") #yet empty
for (i in RequiredPackages) { #Installs packages if not yet installed
    if (!require(i, character.only = TRUE)) 
    install.packages(i)
}
BiocManager::install(version = "3.15")
library(BiocManager)
BiocManager::install("STRINGdb")
library(tidyr)
library(dplyr)
library(igraph)
library(STRINGdb)

```

#### Load raw data and change default separator to ";"

```{r}
raw_data_phospho <- read.csv(file = "/home/noah/phosphoproteomics_project/phosphoproteomics/Dataset_Phospho.csv", sep = ";")
raw_data_proteom <- read.csv(file = "/home/noah/phosphoproteomics_project/phosphoproteomics/Dataset_Proteome.csv", sep = ";")
```

#### If loop to omit na.value from all Abundance columns
- grep line selects all columns that contain the string "Abundance" and saves the column number in *Abundance_columns*
- The for loop then selects all row were there is *no* NA value in one of the Abundance columns and copies them to data_phospho to leave the raw data untouched.
- **!(is.na(raw_data_phospho[,i]))** gives out all the rows that don't have an NA value, these get selected

```{r}
Abundance_columns <- grep("Abundance", colnames(raw_data_phospho) )
for (i in Abundance_columns) {
  data_phospho <- raw_data_phospho[!(is.na(raw_data_phospho[,i])), ]
  }
```

#### Calculate Mean for Abundance and adding it as column and Ratio LIF/Control
- grep again Abundance but this time the Control and LIF (case) seperatly. 
- calculate row means each and the ration between the means.

```{r}
Abundance_columns <- grep("Abundance.Control", colnames(data_phospho))
data_phospho$Abudance.Mean.Control <- rowMeans(data_phospho[,c(Abundance_columns)])

Abundance_columns <- grep("Abundance.LIF", colnames(data_phospho))
data_phospho$Abudance.Mean.LIF <- rowMeans(data_phospho[,c(Abundance_columns)])

data_phospho$Abudance.Ratio <- data_phospho$Abudance.Mean.LIF / data_phospho$Abudance.Mean.Control

remove(Abundance_columns, i)
```

#### Calculate p-values
- *t.test* to compare all 3 Control <-> 3 Case values. If they are different then the pvalue < 0.05 **->** indicating a real differences between case & control. If p-value is big the difference is by chanceðŸ˜„ I tried it for row 188 which has a Ration nearly equal to 1 (1.02...) indicating no difference in case vs. control and the p value ~ 0.7 (really bad) also indicating no difference.

```{r}
start_for <- Sys.time()
for (row in 1:nrow(data_phospho)) {
  p_value <- t.test(data_phospho[row,10:12], data_phospho[row,13:15], alternative = "less") 
  #tests if mean of control is different from mean of LIF (case) and assigns it to list p_value
  data_phospho$Abudance.pvalue[row] <- p_value$p.value 
  #selects p.value from list and assigns it to new column"Abudance.pvalue" in the correct row
  }
end_for <- Sys.time()
end_for - start_for #We wanted to compare calculation time to compare the methods

#Alice quicker approach
df_copy <- dplyr::tibble(data_phospho) # Copy df
start_alice <- Sys.time()
df_copy[] <- lapply(df_copy, function(x) as.numeric(as.character(x)))
df_copy$pValues <- apply(df_copy, 1, function(x) t.test(x[10:12],x[13:15], alternative = "less", paired = F)$p.value)
end_alice <- Sys.time()
end_alice-start_alice #Proves that apply is x4 faster then loop
remove(end_alice,end_for,start_alice,start_for,row,p_value, df_copy)
```

####Adding a Volcano plot to explore the initial data

```{r}
### Phospho volcano plot
# Calculate LIF/Control ratio
phospho <- data_phospho
phospho$FC <- data_phospho$Abudance.Mean.LIF / data_phospho$Abudance.Mean.Control
phospho$log2_FC <- log2(phospho$FC)
phospho$diffexpressed <- "NO"
phospho$diffexpressed[phospho$log2_FC > 1 & phospho$Abudance.pvalue < 0.05] <- "UP"
phospho$diffexpressed[phospho$log2_FC < -1 & phospho$Abudance.pvalue < 0.05] <- "DOWN"

phospho$delabel <- NA
phospho$delabel[phospho$diffexpressed != "NO"] <- phospho$Master.Protein.Accessions[phospho$diffexpressed != "NO"]

##Addition to generate "real names" not Uniprot IDs
string_db_volcano <- STRINGdb$new( version="11.0b", species=10090, score_threshold=1, input_directory="")
Mapping_phospho <- string_db_volcano$map(phospho, "delabel", removeUnmappedRows = F)
Mapping_phospho <- string_db_volcano$add_proteins_description(Mapping_phospho) #AddÂ´s protein information to STRINGidÂ´s 
colnames(Mapping_phospho)
#Volcano plot overview
ggplot(data=Mapping_phospho, aes(x=log2_FC, y=-log10(Abudance.pvalue), col=diffexpressed, label=preferred_name))+
  geom_point()+
  theme_minimal()+
  geom_vline(xintercept=c(-1, 1), col="red") +
  geom_hline(yintercept=-log10(0.05), col="red")

ggsave("~/phosphoproteomics_project/results/Zoomed_out_Volcano.png", width = 1500, height = 1000, units = "px")
#Detail/Zoomed in
ggplot(data=Mapping_phospho, aes(x=log2_FC, y=-log10(Abudance.pvalue), col=diffexpressed, label=preferred_name))+
  geom_point()+
  theme_minimal()+
  geom_vline(xintercept=c(-1, 1), col="red") +
  geom_hline(yintercept=-log10(0.05), col="red") + 
  coord_cartesian(xlim = c(1,3.5), ylim = c(0.5, 6))+
  geom_label_repel()

ggsave("~/phosphoproteomics_project/results/Zoomed_in_Volcano.png", width = 1500, height = 1000, units = "px")

remove(phospho, Mapping_phospho, string_db_volcano)
```

#### Subsetting data_phospho for ratio values >= 2
- a. Remove peptides without quantitative values -> Already done in "If loop to omit na.value from all Abundance columns" thereby creating the data_phospho
- Here just the data.frame is subset, selecting only Ratios >= 2 and p-values <= 0.05

```{r}
more_phosphorylated <- subset.data.frame(data_phospho, subset = data_phospho$Abudance.Ratio >= 2) #Filters out all ratios below 2-fold
more_phosphorylated <- subset.data.frame(more_phosphorylated, subset = more_phosphorylated$Abudance.pvalue <= 0.05) # Filters out all non-significant p-values
remove(data_phospho)
```

#### Building network map of the proteins

```{r}
##Lower score_threshold, allowing more connections
string_db_low <- STRINGdb$new(version="11.0b", species=10090, score_threshold=1, input_directory="") #species = mouse identifier, score threshold = if one interaction this will be mapped, no input directory data stored only temporary
hits_low <- string_db_low$map(more_phosphorylated, "Master.Protein.Accessions", removeUnmappedRows = F) #mapping the UNIPROT Ids from the first column to get STRING identifiers

string_db_low$plot_network(hits_low$STRING_id) #plotting network
string_db_low$get_png(hits_low$STRING_id, file = "~/phosphoproteomics_project/results/Network_low.png") #Saving photo

##Higher score_threshold, allowing less connections
string_db_high <- STRINGdb$new(version="11.0b", species=10090, score_threshold=200, input_directory="") #species = mouse identifier, score threshold = if one interaction this will be mapped, no input directory data stored only temporary
hits_high <- string_db_high$map(more_phosphorylated, "Master.Protein.Accessions", removeUnmappedRows = F) #mapping the UNIPROT Ids from the first column to get STRING identifiers

string_db_high$plot_network(hits_high$STRING_id) #plotting network
string_db_high$get_png(hits_high$STRING_id, file = "~/phosphoproteomics_project/results/Network_high.png") #Saving photo
```


#### Way to identify the Proteins Stat5b is connected to.
- There is also a link to the [STRINGdb website](https://version-11-0b.string-db.org/cgi/link?to=8602E81F655D156B) with the Proteins connected to Stat5b in this dataset.

```{r}
##new better way 
i <- grep("P42232", hits$Master.Protein.Accessions) 
Stat5b <- string_db$mp("P42232") #mapping the UNIPROT Ids 
Stat5b
new_start <- Sys.time()
get <- string_db$get_subnetwork(hits$STRING_id) #builds subnetwork from every entry in STRING_id
ghi <- get[[Stat5b]][1] ##gives the list entry of "get" that lists all 18 entries that interact with Stat5b
hg <- unique(ghi$`10090.ENSMUSP00000102981`) #gives the unique interaction (9 out of 18), 
mat <- as_ids(ghi$`10090.ENSMUSP00000102981`) #function as_ids from the igraph package reads the class("igraph.vs") and collapses it into a matrix
Proteins_connected_to_Stat5b_quick_way <- as.data.frame(unique(mat))
names(Proteins_connected_to_Stat5b_quick_way)[1] <- "STRING_id" #Renaming column so that add_protein_description recognizes it
Proteins_connected_to_Stat5b_quick_way[(nrow(Proteins_connected_to_Stat5b_quick_way)+1),] <- Stat5b #Adds Stat5b to map its connections
Proteins_connected_to_Stat5b_quick_way <- string_db$add_proteins_description(Proteins_connected_to_Stat5b_quick_way) #AddÂ´s protein information to STRINGidÂ´s
new_end <- Sys.time()
new_end-new_start
Proteins_connected_to_Stat5b_quick_way
remove(get, ghi, hg, i, mat, new_end, new_start, Stat5b)
##New method is 97x times quicker!
string_db$plot_network(Proteins_connected_to_Stat5b_quick_way$STRING_id) #plotting network
##Tryout
link <- string_db$get_link(Proteins_connected_to_Stat5b_quick_way$STRING_id)
link #Provides ling to the STRINGdb page
```

#### Identifying Pathways

```{r}
#Identifying only for Proteins connected to Stat5b
enrichment <- string_db$get_enrichment(Proteins_connected_to_Stat5b_quick_way, category = "KEGG")
print(enrichment[,c(3,4,10)])

#Identifying pathways also for Proteins with a ratio >=2 and p.value <= 0.05.
enrichment <- string_db$get_enrichment(more_phosphorylated, category = "KEGG")
print(enrichment[,c(3,4,10)])

```

